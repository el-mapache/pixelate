<!Doctype html>
<html>
  <head>
    <style>
      body {
        margin: 0;
        background-color: #000000;
        height: 100vh;
      }

      #pix {
        width: 450px;
        height: 450px;
        color: #FFFFFF;
        font-family: sans-serif;
        font-size: 60px;
        letter-spacing: -6px;
        line-height: .2;
        margin-left: 20px;
        margin-top: 40px;
      }

      #pix-canvas {
        margin-top: 20px;
      }

      .flexy {
        display: flex;
      }

      .offset60 {
        margin-left: 60px;
      }
    </style>
  </head>
  <body>
    <div class="offset60">
      <div class="flexy">
        <canvas id="pix-canvas" height=200 width=200></canvas>
        <div id="pix"></div>
      </div>

      <div>
        <input type="file" id="file-picker" name="file-picker"/>
        <label for="file-picker">Choose a file</label>
      </div>
    </div>
    <script src="canvas.js"></script>
    <script src="image-file-reader.js"></script>
    <script src="pixelate.js"></script>
    <script>
      const filePicker = document.getElementById('file-picker');
      const htmlCanvas = document.getElementById('pix-canvas');
      const dotMatrix = document.getElementById('pix');
      const pixler = window.pixler;
      const canvasInterface = pixler.canvasInterface(htmlCanvas);
      const matrixDestWidth = 24;
      const matrixRowLength = matrixDestWidth - 1;

      const processImage = (img) => {
        canvasInterface.write(img);
        //TODO: resize should store next image in backing canvas, but return it in case you want to draw
        canvasInterface.resizeAndDraw(240, 240).then(() => {
          const pixelSize = 10;
          const {
            pixelColorList: colorList,
            imageData: pixelatedColors
          } = pixler.pixelate(canvasInterface.read(), pixelSize);
          const pixelsHeight = Math.ceil(pixelatedColors.height / pixelSize);
          const pixelsWidth = Math.ceil(pixelatedColors.width / pixelSize);
          const matrixNodes = dotMatrix.children;

          // show the final pixelated image
          canvasInterface.write(pixelatedColors);

          for (let y = 0; y < pixelsHeight; y++) {
            for (let x = 0; x < pixelsWidth; x++) {
              const rowOffset = (matrixDestWidth - pixelsWidth - 1) * y + 1;
              const currentPixel = y * pixelsWidth + x;
              const packedColor = colorList[currentPixel];

              if (packedColor) {
                const color = `rgb(
                  ${packedColor >> 24 & 0xff},
                  ${packedColor >> 16 & 0xff},
                  ${packedColor >> 8 & 0xff}
                )`;

                const node = matrixNodes[currentPixel + rowOffset];

                if (!node) continue;

                node.style.color = color;
              }
            }
          }
        });
      };

      const handleFile = async function onChooseFile(fileEvent) {
        const imgFile = await pixler.readFile(fileEvent);
        processImage(imgFile);
      };


      filePicker.addEventListener('change', handleFile);

      const transformedArray = Array(matrixDestWidth * matrixDestWidth)
        .fill()
        .map((_, i) => !(i % matrixRowLength) ? '<span>\n</span>' : '<span>.</span>');

      dotMatrix.innerHTML = transformedArray.join('');
    </script>
  </body>
</html>
